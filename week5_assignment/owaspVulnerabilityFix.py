# owaspVulnerabilityFix for week 5. Explanations and references are in README.md.

# (1) Broken Access Control
from flask import Flask, jsonify, abort
from flask_login import login_required, current_user

@app.route('/profile/<int:user_id>')
@login_required
def view_profile(user_id):
    if current_user.id != user_id and not current_user.is_admin:
        abort(403)
    person = User.query.get(user_id)
    if not person:
        abort(404)
    return jsonify(person.to_dict())

# (2) Account Access Permissions
@app.route('/account/<int:user_id>')
@login_required
def view_account(user_id):
    if current_user.id != user_id and not current_user.is_admin:
        return jsonify({'error': 'Forbidden'}), 403
    acct = db.query(User).filter_by(id=user_id).first()
    if not acct:
        return jsonify({'error': 'Not found'}), 404
    return jsonify(acct.to_dict())

# (3) Cryptographic Failures (fixed weak MD5 hash)
import bcrypt

def make_password_hash(password):
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode(), salt)
    return hashed.decode()

# (4) Cryptographic Failures (fixed weak SHA1 hash)
import bcrypt

def simple_password_hash(password):
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password.encode(), salt).decode()

# (5) SQLi Injection
def fetch_user_by_name(name_value):
    query = "SELECT * FROM users WHERE username = ?"
    cursor.execute(query, (name_value,))
    return cursor.fetchone()

# (6) NoSQL Injection
from flask import request
import re

@app.route('/user')
def read_user():
    name_q = request.args.get('username', '')
    name_q = str(name_q).strip()

    if len(name_q) > 100:
        return jsonify({'error': 'Invalid input'}), 400
    if not re.match(r'^[a-zA-Z0-9_-]+$', name_q):
        return jsonify({'error': 'Invalid characters'}), 400

    doc = db.users.find_one({'username': name_q})
    if not doc:
        return jsonify({'error': 'User not found'}), 404
    return jsonify(doc)

# (7) Password Reset Vulnerability
import secrets
import bcrypt
from datetime import datetime, timedelta

@app.route('/request-reset', methods=['POST'])
def request_reset_link():
    email_raw = request.form.get('email', '').strip().lower()
    owner = User.query.filter_by(email=email_raw).first()

    if owner:
        token_plain = secrets.token_urlsafe(32)
        token_hash = bcrypt.hashpw(token_plain.encode(), bcrypt.gensalt())
        owner.reset_token = token_hash.decode()
        owner.reset_expiry = datetime.utcnow() + timedelta(minutes=30)
        db.session.commit()
        send_reset_email(email_raw, token_plain)

    return jsonify({'message': 'If account exists, reset email sent'}), 200

@app.route('/reset-password', methods=['POST'])
def finish_reset():
    token_input = request.form.get('token', '')
    new_pw = request.form.get('new_password', '')

    if len(new_pw) < 12:
        return jsonify({'error': 'Password too weak'}), 400

    candidates = User.query.filter(User.reset_expiry > datetime.utcnow()).all()
    for u in candidates:
        if u.reset_token and bcrypt.checkpw(token_input.encode(), u.reset_token.encode()):
            u.password = bcrypt.hashpw(new_pw.encode(), bcrypt.gensalt()).decode()
            u.reset_token = None
            u.reset_expiry = None
            db.session.commit()
            return jsonify({'message': 'Password reset successful'}), 200

    return jsonify({'error': 'Invalid or expired token'}), 400

# (8) Software/Data Integrity Failures (SRI helper)
import hashlib
import base64

def make_sri_sha384(file_bytes):
    digest = hashlib.sha384(file_bytes).digest()
    return f"sha384-{base64.b64encode(digest).decode()}"

# (9) Server-Side Request Forgery (SSRF)
import requests
from urllib.parse import urlparse
import socket
import ipaddress

ALLOW_LIST = ['api.trusted-service.com', 'data.partner-site.com']
BLOCK_NETS = ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16',
              '127.0.0.0/8', '169.254.0.0/16', '::1/128', 'fc00::/7']

def url_is_safe(raw_url):
    try:
        parts = urlparse(raw_url)
        if parts.scheme not in ['http', 'https']:
            return False
        if parts.hostname not in ALLOW_LIST:
            return False
        addrs = socket.getaddrinfo(parts.hostname, None)
        for ai in addrs:
            ip = ipaddress.ip_address(ai[4][0])
            for cidr in BLOCK_NETS:
                if ip in ipaddress.ip_network(cidr):
                    return False
        return True
    except Exception:
        return False

def pull_url(raw_url):
    if not url_is_safe(raw_url):
        return None
    try:
        r = requests.get(raw_url, timeout=5)
        return r.text
    except requests.exceptions.RequestException:
        return None

# usage
target = input("Enter URL: ")
body = pull_url(target)
print(body if body else "URL not allowed")

# (10) Identification & Auth Failures
import bcrypt
from datetime import datetime, timedelta

MAX_ATTEMPTS = 5
LOCK_MINUTES = 15

def login_user(name_input, pw_input):
    person = User.query.filter_by(username=name_input).first()

    if not person:
        # burn time to reduce enumeration timing leaks
        bcrypt.checkpw(pw_input.encode(), bcrypt.gensalt())
        return False

    if person.locked_until and person.locked_until > datetime.utcnow():
        return False

    if bcrypt.checkpw(pw_input.encode(), person.password_hash.encode()):
        person.failed_attempts = 0
        person.locked_until = None
        person.last_login = datetime.utcnow()
        db.session.commit()
        return True
    else:
        person.failed_attempts += 1
        if person.failed_attempts >= MAX_ATTEMPTS:
            person.locked_until = datetime.utcnow() + timedelta(minutes=LOCK_MINUTES)
        db.session.commit()
        return False
